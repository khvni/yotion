# Bug Fixes - January 10, 2025

## Issues Fixed

### 1. ReferenceError: Cannot access 'handleSelectOption' before initialization

**Location:** `components/editor/BlockTypeMenu.tsx:77`

**Issue:** The `handleKeyDown` callback referenced `handleSelectOption` in its dependency array before `handleSelectOption` was defined, causing a temporal dead zone error when typing "/" to open the menu.

**Fix:** Moved the `handleSelectOption` function definition before `handleKeyDown` to ensure proper initialization order.

**Changes:**
- Reordered functions in BlockTypeMenu.tsx so `handleSelectOption` is defined at line 55, before `handleKeyDown` which is now at line 114

---

### 2. Enter Key Not Moving Cursor to New Block

**Location:** `components/editor/Editor.tsx:92-109`

**Issue:** When pressing Enter to create a new block, the cursor would not automatically focus on the newly created block. The code used `lastFocusedBlockRef` with a useEffect to focus, but there was a race condition.

**Fix:** Removed the ref-based focus approach and instead added a direct `setTimeout` call after the block is saved to the API, ensuring the new block is rendered before focusing.

**Changes:**
- Removed `lastFocusedBlockRef` variable
- Removed the auto-focus useEffect hook
- Added direct focus logic with setTimeout(50ms) inside the `createNewBlock` function after successful API response

---

### 3. Text Appearing in Reverse Order When Typing

**Location:** `components/editor/TextBlock.tsx:17-43, 182-193`

**Issue:** Text appeared reversed (e.g., "hello" → "olleh") because React was controlling the contentEditable element's content via the `children` prop, which conflicts with user input. Every keystroke would trigger a store update, which triggered a useEffect that reset `textContent`, moving the cursor to the beginning.

**Fix:** 
1. Removed the `children` prop from the contentEditable elements
2. Changed from controlled to uncontrolled contentEditable by setting initial content only once in a useEffect
3. Only sync content from store when the block type changes (external update like from menu)
4. Added `isComposingRef` to track IME composition state
5. Added composition event handlers to prevent interference during typing

**Changes:**
- Added `isComposingRef` and `initializedRef` refs
- Changed content sync useEffect to only run once on mount
- Added a separate useEffect that syncs only on `block.type` changes
- Removed `children: block.content` from commonProps
- Added `onCompositionStart` and `onCompositionEnd` handlers

---

### 4. "/" Menu Not Appearing with Existing Text

**Location:** `components/editor/TextBlock.tsx:113-119`

**Issue:** The "/" command menu would only open when the block was completely empty (`content === ""`), preventing users from opening the menu when there was already text in the block.

**Fix:** Removed the empty content check so the menu opens whenever "/" is pressed, regardless of existing content.

**Changes:**
- Changed condition from `if (e.key === "/" && content === "")` to `if (e.key === "/")`
- Removed the content check entirely from the "/" key handler

---

### 5. Block Type Switching Creating New Blocks Instead of Updating Existing

**Location:** `components/editor/BlockTypeMenu.tsx:55-110` and `components/editor/TextBlock.tsx:27-34`

**Problem:** When using the "/" menu to switch block types (e.g., typing text in a paragraph, pressing "/", then clicking "H1"), the application was creating a brand new block instead of updating the existing block's type. This resulted in:
- The original paragraph block remaining unchanged
- A new H1 block being created below it
- Loss of the original text content

**Root Cause Analysis:**

The bug occurred due to a fundamental misunderstanding in the `BlockTypeMenu` component. The original implementation:
1. Called `addBlock()` to create a new block
2. Then tried to delete the old block
3. This approach failed because it was creating new blocks instead of transforming existing ones

**The Fix:**

Changed the menu to properly update the existing block instead of creating a new one:

**BlockTypeMenu.tsx (lines 55-110):**
```tsx
const handleSelectOption = useCallback(
  async (type: BlockType) => {
    if (!selectedBlockId) {
      closeMenu();
      return;
    }

    const block = blocks.find((b) => b.id === selectedBlockId);
    if (!block) {
      closeMenu();
      return;
    }

    // Get current content from the DOM to preserve it
    const blockElement = document.querySelector(
      `[data-block-id="${selectedBlockId}"] [contenteditable]`
    ) as HTMLElement;
    const currentContent = blockElement?.textContent || block.content;

    // Update block type while preserving content
    const updates: Partial<typeof block> = { type, content: currentContent };

    // Add default metadata for image blocks
    if (type === "image") {
      updates.metadata = { width: 400, height: 300 };
      updates.content = "";
    }

    // Update store
    updateBlock(selectedBlockId, updates);

    // Save to API
    try {
      await fetch(`/api/blocks/${selectedBlockId}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(updates),
      });
    } catch (error) {
      console.error("Failed to update block type:", error);
    }

    closeMenu();

    // Refocus the block
    setTimeout(() => {
      if (type !== "image") {
        const element = document.querySelector(
          `[data-block-id="${selectedBlockId}"] [contenteditable]`
        ) as HTMLElement;
        element?.focus();
      }
    }, 0);
  },
  [selectedBlockId, blocks, updateBlock, closeMenu]
);
```

**Key Changes:**
1. **Removed:** All `addBlock()` and `deleteBlock()` calls
2. **Added:** `updateBlock()` call to modify the existing block in-place
3. **Content Preservation:** Read current content from DOM before updating to ensure no text is lost
4. **API Call:** Changed from POST (create) to PATCH (update) to `/api/blocks/${selectedBlockId}`
5. **Focus Management:** Refocus the same block after type change (except for image blocks)

**TextBlock.tsx (lines 27-34):**
```tsx
// Update content when block TYPE changes (external update like from menu)
// This runs when switching between p/h1/h2/h3, which creates a new DOM element
useEffect(() => {
  if (contentRef.current) {
    contentRef.current.textContent = block.content;
    lastContentRef.current = block.content;
  }
}, [block.type]);
```

This useEffect ensures that when React switches between DOM element types (e.g., `<p>` → `<h1>`), the content is properly synced from the store to the new element.

**How It Works Now:**

1. User types "Hello World" in a paragraph block
2. User presses "/" to open the menu (menu stores the current block's ID via `selectedBlockId`)
3. User clicks "Heading 1"
4. Menu handler:
   - Finds the block by `selectedBlockId`
   - Reads current DOM content: "Hello World"
   - Calls `updateBlock(selectedBlockId, { type: "h1", content: "Hello World" })`
   - Sends PATCH request to `/api/blocks/${selectedBlockId}`
5. React re-renders:
   - Unmounts the old `<p>` element
   - Mounts a new `<h1>` element
   - TextBlock's type-change useEffect fires
   - Sets the new element's textContent to "Hello World"
6. Focus is restored to the updated block

**Result:** The same block is now an H1 with "Hello World" text preserved. No new blocks are created.

---

### 6. Image Block Missing Dropzone Functionality

**Location:** `components/editor/ImageBlock.tsx`

**Issue:** Clicking "Image" from the "/" menu didn't provide an intuitive way to upload images. Users had to manually paste image URLs into a text input, which is cumbersome. There was no drag-and-drop or file upload functionality.

**Fix:** Integrated `react-dropzone` library to provide a modern drag-and-drop interface for image uploads.

**Changes:**
- Installed `react-dropzone` package
- Added `useDropzone` hook with file handling logic
- Implemented `onDrop` callback that:
  - Accepts image files (PNG, JPG, JPEG, GIF, WEBP)
  - Reads files using FileReader API
  - Converts to base64 data URLs
  - Updates block content and saves to API
- Updated UI to show:
  - "Drag & drop image here" with icon when no image
  - "or click to browse" instruction
  - "PNG, JPG, GIF up to 10MB" file type info
  - Blue highlight when dragging files over the dropzone
  - "Drop to replace image" overlay when dragging over existing image
- Added `noClick: !!block.content` to prevent click-to-browse when image already exists (drag-and-drop still works)
- Kept the URL input field as an alternative method with updated placeholder "Or paste image URL..."

**Files Modified:**
- `components/editor/ImageBlock.tsx`: Complete rewrite of the empty state to use dropzone
- `package.json`: Added `react-dropzone` dependency

---

## Summary

All fixes were tested using Playwright browser automation on port 3001:
- ✅ Text types in correct order (left to right)
- ✅ Enter key creates new block and moves cursor to it
- ✅ "/" menu appears even with existing text
- ✅ Selecting block types (H1, H2, H3) from menu updates the existing block (no new blocks created)
- ✅ Text content is preserved when switching block types
- ✅ Image block displays drag-and-drop interface when created via "/" menu
- ✅ Dropzone shows clear instructions and accepts multiple upload methods
- ✅ No console errors when typing "/" or switching block types

## Technical Notes

### ContentEditable Best Practices

The key lesson from the text reversal bug: **Never mix controlled and uncontrolled contentEditable elements**.

**Wrong approach:**
```tsx
<div contentEditable {...props}>
  {block.content}  // ❌ React controls content
</div>

useEffect(() => {
  element.textContent = block.content;  // ❌ Also updating DOM directly
}, [block.content]);
```

**Correct approach:**
```tsx
<div contentEditable {...props} />  // ✅ No children prop

useEffect(() => {
  if (!initialized) {
    element.textContent = block.content;  // ✅ Set once on mount
    setInitialized(true);
  }
}, []);

// Only sync on external changes (like type switching)
useEffect(() => {
  element.textContent = block.content;  // ✅ Sync when type changes
}, [block.type]);
```

This ensures the DOM is the source of truth during user input, preventing cursor position issues and text reversal.

### Block Type Switching Flow

When switching block types (e.g., paragraph → h1):
1. User types text into paragraph block
2. User presses "/" to open menu (menu stores block ID in `selectedBlockId`)
3. User clicks "H1" option
4. BlockTypeMenu reads current DOM content via `querySelector`
5. BlockTypeMenu calls `updateBlock(selectedBlockId, { type: "h1", content: currentContent })`
6. BlockTypeMenu sends PATCH request to `/api/blocks/${selectedBlockId}`
7. React unmounts old `<p>` and mounts new `<h1>` element
8. TextBlock's type-change useEffect fires (triggered by `block.type` change)
9. useEffect syncs content from store (which has the preserved text) to new DOM element
10. BlockTypeMenu refocuses the element

This flow ensures:
- **No new blocks are created** (uses PATCH instead of POST)
- **Content is preserved** (reads from DOM before update)
- **Proper synchronization** (type-change useEffect handles React's element swap)

### React Dropzone Integration

The image block uses `react-dropzone` with the following configuration:
- **Accept:** Only image files (PNG, JPG, JPEG, GIF, WEBP)
- **Multiple:** false (single file upload)
- **noClick:** Disabled when image already exists to prevent accidental file dialog
- **File Processing:** Files are converted to base64 data URLs using FileReader API
- **Storage:** Base64 strings are stored directly in block content (suitable for small images, but consider cloud storage for production)

**Key UI States:**
1. Empty state: Shows dropzone with instructions
2. Dragging: Highlights border blue and shows "Drop here" message
3. With image: Displays image with resize handles, allows drag-to-replace
4. URL input: Always visible as alternative upload method
