# Bug Fixes - January 10, 2025

## Issues Fixed

### 1. ReferenceError: Cannot access 'handleSelectOption' before initialization

**Location:** `components/editor/BlockTypeMenu.tsx:77`

**Issue:** The `handleKeyDown` callback referenced `handleSelectOption` in its dependency array before `handleSelectOption` was defined, causing a temporal dead zone error when typing "/" to open the menu.

**Fix:** Moved the `handleSelectOption` function definition before `handleKeyDown` to ensure proper initialization order.

**Changes:**
- Reordered functions in BlockTypeMenu.tsx so `handleSelectOption` is defined at line 55, before `handleKeyDown` which is now at line 114

---

### 2. Enter Key Not Moving Cursor to New Block

**Location:** `components/editor/Editor.tsx:92-109`

**Issue:** When pressing Enter to create a new block, the cursor would not automatically focus on the newly created block. The code used `lastFocusedBlockRef` with a useEffect to focus, but there was a race condition.

**Fix:** Removed the ref-based focus approach and instead added a direct `setTimeout` call after the block is saved to the API, ensuring the new block is rendered before focusing.

**Changes:**
- Removed `lastFocusedBlockRef` variable
- Removed the auto-focus useEffect hook
- Added direct focus logic with setTimeout(50ms) inside the `createNewBlock` function after successful API response

---

### 3. Text Appearing in Reverse Order When Typing

**Location:** `components/editor/TextBlock.tsx:17-43, 182-193`

**Issue:** Text appeared reversed (e.g., "hello" → "olleh") because React was controlling the contentEditable element's content via the `children` prop, which conflicts with user input. Every keystroke would trigger a store update, which triggered a useEffect that reset `textContent`, moving the cursor to the beginning.

**Fix:** 
1. Removed the `children` prop from the contentEditable elements
2. Changed from controlled to uncontrolled contentEditable by setting initial content only once in a useEffect
3. Only sync content from store when the block type changes (external update like from menu)
4. Added `isComposingRef` to track IME composition state
5. Added composition event handlers to prevent interference during typing

**Changes:**
- Added `isComposingRef` and `initializedRef` refs
- Changed content sync useEffect to only run once on mount
- Added a separate useEffect that syncs only on `block.type` changes
- Removed `children: block.content` from commonProps
- Added `onCompositionStart` and `onCompositionEnd` handlers

---

### 4. "/" Menu Not Appearing with Existing Text

**Location:** `components/editor/TextBlock.tsx:113-119`

**Issue:** The "/" command menu would only open when the block was completely empty (`content === ""`), preventing users from opening the menu when there was already text in the block.

**Fix:** Removed the empty content check so the menu opens whenever "/" is pressed, regardless of existing content.

**Changes:**
- Changed condition from `if (e.key === "/" && content === "")` to `if (e.key === "/")`
- Removed the content check entirely from the "/" key handler

---

### 5. Block Type Switching Creating New Blocks Instead of Updating Existing

**Location:** `components/editor/BlockTypeMenu.tsx:55-110` and `components/editor/TextBlock.tsx:27-34`

**Problem:** When using the "/" menu to switch block types (e.g., typing text in a paragraph, pressing "/", then clicking "H1"), the application was creating a brand new block instead of updating the existing block's type. This resulted in:
- The original paragraph block remaining unchanged
- A new H1 block being created below it
- Loss of the original text content

**Root Cause Analysis:**

The bug occurred due to a fundamental misunderstanding in the `BlockTypeMenu` component. The original implementation:
1. Called `addBlock()` to create a new block
2. Then tried to delete the old block
3. This approach failed because it was creating new blocks instead of transforming existing ones

**The Fix:**

Changed the menu to properly update the existing block instead of creating a new one:

**BlockTypeMenu.tsx (lines 55-110):**
```tsx
const handleSelectOption = useCallback(
  async (type: BlockType) => {
    if (!selectedBlockId) {
      closeMenu();
      return;
    }

    const block = blocks.find((b) => b.id === selectedBlockId);
    if (!block) {
      closeMenu();
      return;
    }

    // Get current content from the DOM to preserve it
    const blockElement = document.querySelector(
      `[data-block-id="${selectedBlockId}"] [contenteditable]`
    ) as HTMLElement;
    const currentContent = blockElement?.textContent || block.content;

    // Update block type while preserving content
    const updates: Partial<typeof block> = { type, content: currentContent };

    // Add default metadata for image blocks
    if (type === "image") {
      updates.metadata = { width: 400, height: 300 };
      updates.content = "";
    }

    // Update store
    updateBlock(selectedBlockId, updates);

    // Save to API
    try {
      await fetch(`/api/blocks/${selectedBlockId}`, {
        method: "PATCH",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(updates),
      });
    } catch (error) {
      console.error("Failed to update block type:", error);
    }

    closeMenu();

    // Refocus the block
    setTimeout(() => {
      if (type !== "image") {
        const element = document.querySelector(
          `[data-block-id="${selectedBlockId}"] [contenteditable]`
        ) as HTMLElement;
        element?.focus();
      }
    }, 0);
  },
  [selectedBlockId, blocks, updateBlock, closeMenu]
);
```

**Key Changes:**
1. **Removed:** All `addBlock()` and `deleteBlock()` calls
2. **Added:** `updateBlock()` call to modify the existing block in-place
3. **Content Preservation:** Read current content from DOM before updating to ensure no text is lost
4. **API Call:** Changed from POST (create) to PATCH (update) to `/api/blocks/${selectedBlockId}`
5. **Focus Management:** Refocus the same block after type change (except for image blocks)

**TextBlock.tsx (lines 27-34):**
```tsx
// Update content when block TYPE changes (external update like from menu)
// This runs when switching between p/h1/h2/h3, which creates a new DOM element
useEffect(() => {
  if (contentRef.current) {
    contentRef.current.textContent = block.content;
    lastContentRef.current = block.content;
  }
}, [block.type]);
```

This useEffect ensures that when React switches between DOM element types (e.g., `<p>` → `<h1>`), the content is properly synced from the store to the new element.

**How It Works Now:**

1. User types "Hello World" in a paragraph block
2. User presses "/" to open the menu (menu stores the current block's ID via `selectedBlockId`)
3. User clicks "Heading 1"
4. Menu handler:
   - Finds the block by `selectedBlockId`
   - Reads current DOM content: "Hello World"
   - Calls `updateBlock(selectedBlockId, { type: "h1", content: "Hello World" })`
   - Sends PATCH request to `/api/blocks/${selectedBlockId}`
5. React re-renders:
   - Unmounts the old `<p>` element
   - Mounts a new `<h1>` element
   - TextBlock's type-change useEffect fires
   - Sets the new element's textContent to "Hello World"
6. Focus is restored to the updated block

**Result:** The same block is now an H1 with "Hello World" text preserved. No new blocks are created.

---

### 6. Image Block Missing Dropzone Functionality

**Location:** `components/editor/ImageBlock.tsx`

**Issue:** Clicking "Image" from the "/" menu didn't provide an intuitive way to upload images. Users had to manually paste image URLs into a text input, which is cumbersome. There was no drag-and-drop or file upload functionality.

**Fix:** Integrated `react-dropzone` library to provide a modern drag-and-drop interface for image uploads.

**Changes:**
- Installed `react-dropzone` package
- Added `useDropzone` hook with file handling logic
- Implemented `onDrop` callback that:
  - Accepts image files (PNG, JPG, JPEG, GIF, WEBP)
  - Reads files using FileReader API
  - Converts to base64 data URLs
  - Updates block content and saves to API
- Updated UI to show:
  - "Drag & drop image here" with icon when no image
  - "or click to browse" instruction
  - "PNG, JPG, GIF up to 10MB" file type info
  - Blue highlight when dragging files over the dropzone
  - "Drop to replace image" overlay when dragging over existing image
- Added `noClick: !!block.content` to prevent click-to-browse when image already exists (drag-and-drop still works)
- Kept the URL input field as an alternative method with updated placeholder "Or paste image URL..."

**Files Modified:**
- `components/editor/ImageBlock.tsx`: Complete rewrite of the empty state to use dropzone
- `package.json`: Added `react-dropzone` dependency

---

### 7. API Response Format Bug: Blocks Created with Undefined IDs ✅ FIXED

**Location:** `app/api/blocks/route.ts:54`

**Symptom:** When creating multiple empty blocks rapidly (e.g., pressing Enter twice), typing in one empty block caused ALL empty blocks to display the same text. This was a critical data corruption bug.

**Example:**
1. User presses Enter twice from the last block → creates 2 empty blocks
2. User types "test" in the second empty block
3. BOTH empty blocks now showed "test" instead of just the second one

**Root Cause - API Response Mismatch:**

The bug was caused by a mismatch between the API response format and what the client expected:

**API was returning:** `{ block: { id: "...", type: "...", ... } }`
**Client was expecting:** `{ id: "...", type: "...", ... }`

When the client called `await response.json()`, it received an object with a `block` property, not the block itself. This meant `savedBlock.id` was `undefined` because the actual block data was nested inside `savedBlock.block.id`.

**Timeline of the Bug:**
```
T1: User creates new block by pressing Enter
    - Client creates optimistic block with UUID: "abc-123"
    - Client adds block to store
    - Client sends POST to /api/blocks

T2: API responds with { block: { id: "xyz-789", ... } }
    - Client does: const savedBlock = await response.json()
    - savedBlock = { block: { id: "xyz-789", ... } }
    - savedBlock.id = undefined (should be "xyz-789")
    
T3: Client tries to replace optimistic block
    - Filters out optimistic block with id="abc-123" ✅
    - Adds savedBlock with id=undefined ❌
    - Now store has a block with undefined ID

T4: User types in that block
    - TextBlock calls updateBlock(undefined, { content: "test" })
    - Store's updateBlock matches ALL blocks with id=undefined
    - All blocks with undefined IDs get updated simultaneously
```

**The Fix:**

Changed the API response to return the block directly instead of wrapped in an object:

**app/api/blocks/route.ts (line 54):**
```tsx
// BEFORE (returns wrapped object):
const block = await createBlock(input);
return NextResponse.json({ block }, { status: 201 });

// AFTER (returns block directly):
const block = await createBlock(input);
return NextResponse.json(block, { status: 201 });
```

**Additional Fixes for Stale Closures:**

While investigating this bug, we also discovered and fixed stale closure issues in the Editor component:

1. **lib/store.ts - Added functional setState support:**
   ```tsx
   // Updated setBlocks to accept function or value
   setBlocks: (blocks: Block[] | ((prevBlocks: Block[]) => Block[])) => void;
   
   // Implementation checks type and handles both
   setBlocks: (blocks) =>
     set((state) => ({
       blocks: typeof blocks === "function" ? blocks(state.blocks) : blocks,
     })),
   ```

2. **components/editor/Editor.tsx - Line 145-152 (Optimistic update):**
   ```tsx
   // BEFORE (stale closure):
   const updatedBlocks = blocks.map(block => ...);
   setBlocks([...updatedBlocks, newBlock]);
   
   // AFTER (functional form):
   setBlocks((currentBlocks) => {
     const updated = currentBlocks.map((block) =>
       block.order >= newOrder ? { ...block, order: block.order + 1 } : block
     );
     return [...updated, newBlock].sort((a, b) => a.order - b.order);
   });
   ```

3. **components/editor/Editor.tsx - Line 173-176 (API response handler):**
   ```tsx
   // BEFORE (stale closure):
   setBlocks([...updatedBlocks.filter(b => b.id !== newBlock.id), savedBlock]);
   
   // AFTER (functional form):
   setBlocks((currentBlocks) => {
     const filtered = currentBlocks.filter((b) => b.id !== newBlock.id);
     return [...filtered, savedBlock].sort((a, b) => a.order - b.order);
   });
   ```

**Testing:**
1. Created fresh database by restarting server
2. Pressed Enter twice to create two empty blocks
3. Typed "only in second block" into the second block
4. ✅ First block remained empty with placeholder text
5. ✅ Second block displayed "only in second block"
6. ✅ No console errors about undefined IDs
7. ✅ Server logs showed successful POST and PATCH requests with valid IDs

**Files Modified:**
- `app/api/blocks/route.ts`: Changed response format from `{ block }` to direct block object
- `lib/store.ts`: Added functional setState support
- `components/editor/Editor.tsx`: Changed two setBlocks calls to use functional form

**Status:** ✅ **FIXED AND TESTED**

---

## Summary

All fixes were tested using Playwright browser automation on port 3001:
- ✅ Text types in correct order (left to right)
- ✅ Enter key creates new block and moves cursor to it
- ✅ "/" menu appears even with existing text
- ✅ Selecting block types (H1, H2, H3) from menu updates the existing block (no new blocks created)
- ✅ Text content is preserved when switching block types
- ✅ Image block displays drag-and-drop interface when created via "/" menu
- ✅ Dropzone shows clear instructions and accepts multiple upload methods
- ✅ No console errors when typing "/" or switching block types
- ✅ **FIXED:** Multiple empty blocks remain isolated when typing (Bug #7 - API response format fixed)

## Technical Notes

### ContentEditable Best Practices

The key lesson from the text reversal bug: **Never mix controlled and uncontrolled contentEditable elements**.

**Wrong approach:**
```tsx
<div contentEditable {...props}>
  {block.content}  // ❌ React controls content
</div>

useEffect(() => {
  element.textContent = block.content;  // ❌ Also updating DOM directly
}, [block.content]);
```

**Correct approach:**
```tsx
<div contentEditable {...props} />  // ✅ No children prop

useEffect(() => {
  if (!initialized) {
    element.textContent = block.content;  // ✅ Set once on mount
    setInitialized(true);
  }
}, []);

// Only sync on external changes (like type switching)
useEffect(() => {
  element.textContent = block.content;  // ✅ Sync when type changes
}, [block.type]);
```

This ensures the DOM is the source of truth during user input, preventing cursor position issues and text reversal.

### Block Type Switching Flow

When switching block types (e.g., paragraph → h1):
1. User types text into paragraph block
2. User presses "/" to open menu (menu stores block ID in `selectedBlockId`)
3. User clicks "H1" option
4. BlockTypeMenu reads current DOM content via `querySelector`
5. BlockTypeMenu calls `updateBlock(selectedBlockId, { type: "h1", content: currentContent })`
6. BlockTypeMenu sends PATCH request to `/api/blocks/${selectedBlockId}`
7. React unmounts old `<p>` and mounts new `<h1>` element
8. TextBlock's type-change useEffect fires (triggered by `block.type` change)
9. useEffect syncs content from store (which has the preserved text) to new DOM element
10. BlockTypeMenu refocuses the element

This flow ensures:
- **No new blocks are created** (uses PATCH instead of POST)
- **Content is preserved** (reads from DOM before update)
- **Proper synchronization** (type-change useEffect handles React's element swap)

### React Dropzone Integration

The image block uses `react-dropzone` with the following configuration:
- **Accept:** Only image files (PNG, JPG, JPEG, GIF, WEBP)
- **Multiple:** false (single file upload)
- **noClick:** Disabled when image already exists to prevent accidental file dialog
- **File Processing:** Files are converted to base64 data URLs using FileReader API
- **Storage:** Base64 strings are stored directly in block content (suitable for small images, but consider cloud storage for production)

**Key UI States:**
1. Empty state: Shows dropzone with instructions
2. Dragging: Highlights border blue and shows "Drop here" message
3. With image: Displays image with resize handles, allows drag-to-replace
4. URL input: Always visible as alternative upload method

### API Response Formats

**Critical Pattern:** Always ensure client and server agree on response format.

**Wrong (caused Bug #7):**
```tsx
// Server
return NextResponse.json({ block }, { status: 201 });

// Client
const savedBlock = await response.json();
console.log(savedBlock.id); // undefined! Need savedBlock.block.id
```

**Correct:**
```tsx
// Server returns unwrapped object
return NextResponse.json(block, { status: 201 });

// Client gets block directly
const savedBlock = await response.json();
console.log(savedBlock.id); // works!
```

This pattern applies to all API endpoints. Always verify response structure matches client expectations.

### Stale Closures in React

**The Pattern:**
React callbacks (useCallback, event handlers) capture variables from their enclosing scope at the time they're created. If these callbacks perform async operations, they may use stale data when they eventually execute.

**Example:**
```tsx
const createNewBlock = useCallback(async (afterBlockId) => {
  const afterBlock = blocks.find(b => b.id === afterBlockId);  // ← captures 'blocks' from closure
  
  const updatedBlocks = blocks.map(...);  // ← uses captured 'blocks'
  setBlocks([...updatedBlocks, newBlock]);  // ← setState with stale data
  
  const response = await fetch('/api/blocks', ...);  // ← async operation
  const savedBlock = await response.json();
  
  // By the time we get here, 'blocks' is stale!
  // User may have created more blocks, but we still have old 'blocks' array
  setBlocks([...updatedBlocks, savedBlock]);  // ← BUG: loses newer blocks
}, [blocks]);  // ← recreates callback when blocks change, but doesn't help with async
```

**The Solution - Functional setState:**
Use the functional form of setState to access the current state at the time of update, not the captured state:

```tsx
// WRONG - uses stale closure
setBlocks([...blocks, newBlock]);

// RIGHT - gets current state
setBlocks((currentBlocks) => [...currentBlocks, newBlock]);
```

**Critical Locations to Use Functional setState:**
1. Inside async callbacks (after fetch, setTimeout, etc.)
2. In event handlers that may fire multiple times quickly
3. When updating state based on previous state
4. In optimistic UI updates followed by API calls

**Red Flags:**
- Using captured variables (from closure) after `await`
- Multiple rapid state updates (e.g., pressing Enter twice quickly)
- Race conditions between optimistic updates and API responses
- State updates that depend on previous state but don't use functional form